package org.cloudbus.cloudsim;

import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;

import org.apache.commons.math3.ode.FirstOrderDifferentialEquations;
import org.apache.commons.math3.ode.FirstOrderIntegrator;
import org.apache.commons.math3.ode.nonstiff.DormandPrince853Integrator;
import org.apache.commons.math3.ode.sampling.StepHandler;
import org.apache.commons.math3.ode.sampling.StepInterpolator;
import org.cloudbus.cloudsim.examples.LotkaVolterra;
import org.cloudbus.cloudsim.examples.LotkaVolterraPojo;

public class ElasticDataCenter extends DatacenterBroker{
	
private int totalVmPool=40;
public static boolean isStillRunning=true;
Timer time =null;
	public ElasticDataCenter(String name) throws Exception {
		super(name);
		// TODO Auto-generated constructor stub
	}
	
	public void monitor(){
		System.out.println("inside elastic data center monitor");
		
		 time = new Timer();
		ScheduledTask st = new ScheduledTask();
		time.schedule(st, 0, 10);
		
		
	}
	/**
	 * below method calculates the utilization after certain interval
	 */
 public double getUtilization(){
	double totalVmUtilization=0.0;
	double sumOfCloudletLength=0.0;
	List<Vm> vmList12=getVmsCreatedList();
	if(vmList12.size()>0)
	System.out.println("inside run method size:::"+vmList.size());
	  for(Vm vm:vmList){
	 sumOfCloudletLength=  vm.getCloudletScheduler().getElasticUtilization();
	 totalVmUtilization=totalVmUtilization+(totalVmUtilization/(vm.getNumberOfPes()*vm.getMips()));
	 
		
	  }
	  double finalUtilization=totalVmUtilization/vmList.size();
	  return finalUtilization;
 }
 
 public class ScheduledTask extends TimerTask {
	 
		double totalUtilization=0; 
		double maxUtilization=0.8;
		double minUtilization=0.2;

		// Add your task here
		public void run() {
			
			LotkaVolterraPojo lkpojo=null;
			List<Vm> newList=null;
			totalUtilization=getUtilization();
			if(totalUtilization>maxUtilization){
				//need to add more VMS from resource pool
				//call LK algorithm
				 lkpojo=selectLkPojoForVmIncreasingCloudletDecreasing(vmList.size(),cloudletSubmittedList.size());
				 newList= createVM(getId(),lkpojo.getVmNUmber(),0);
				 submitVmList(newList);
			}
			if(totalUtilization<minUtilization){
			//kill VMS
			}
			if(!isStillRunning)
				time.cancel();
	
		}
	}
 
 /**
	 * This is the common method for prey Increasing/ decreasing which runs the lotka volterra ode and generated list of solutions
	 * @param vmNumber available vmNumber in the system
	 * @param cloudLetNumber cloudlets in the data center
	 * @param vmCoeff coeff of the vm in the ode
	 * @param cloudCoeff coeff of the cloudlet in the ode
	 * @return List of LotkaVolterra pojo generated by ode
	 */
	private List<LotkaVolterraPojo> callLotkaVolterra(double vmNumber,double cloudLetNumber,double vmCoeff,double cloudCoeff){
		
		
		final List<LotkaVolterraPojo> lkPojoList=new ArrayList<LotkaVolterraPojo>();
		FirstOrderIntegrator dp853 = new DormandPrince853Integrator(1.0e-8, 0.1, 1.0e-10, 1.0e-10);
		FirstOrderDifferentialEquations ode =new LotkaVolterra(vmCoeff, cloudCoeff);
		double[] y = new double[] { vmNumber, cloudLetNumber };
		StepHandler stepHandler = new StepHandler() {
			LotkaVolterraPojo lkPojo=null;
		    public void init (double t0, double[] y0, double t) {
		    }

		    public void handleStep (StepInterpolator interpolator, boolean isLast) {
		      double t = interpolator.getCurrentTime();
		      double[] y = interpolator.getInterpolatedState();
		      lkPojo=new LotkaVolterraPojo();
		      lkPojo.setVmNUmber(new Double(y[0]).intValue());
		      lkPojo.setCloudletNumber(new Double(y[1]).intValue());
		      lkPojoList.add(lkPojo);
		      System.out.println("->" + t + " " + y[0] + " " + y[1]);
		    }
		  };
		  dp853.addStepHandler(stepHandler);
		dp853.integrate(ode, 0.0, y, 18.0, y);
		System.out.println(y[0]);
		System.out.println(y[1]);
		return lkPojoList;
		
	}
	/**
	 * This method returns the selected lk generated pojo, which contains the required vmnumber and cloudlet number
	 * @param vmNumber
	 * @param cloudLetNumber
	 * @return
	 */
	public LotkaVolterraPojo selectLkPojoForVmIncreasingCloudletDecreasing(double vmNumber,double cloudLetNumber){
		LotkaVolterraPojo lkPojo=new LotkaVolterraPojo();
		
		if(vmNumber==0.0)
			vmNumber=1.0;
		double vmCoeff=vmNumber+100;
		double cloudCoeff=cloudLetNumber-20;
		List<LotkaVolterraPojo> callLotkaVolterra=callLotkaVolterra(vmNumber,cloudLetNumber,vmCoeff,cloudCoeff);
		Log.printLine("total Vm number"+cloudLetNumber+"vmNumber"+vmNumber);
		for(LotkaVolterraPojo lotkaVolterraPojo:callLotkaVolterra){
			if( lotkaVolterraPojo.getVmNUmber()>vmList.size() &&(int) lotkaVolterraPojo.getVmNUmber()<new Double(vmNumber+totalVmPool).intValue()){
				lkPojo.setCloudletNumber(lotkaVolterraPojo.getCloudletNumber());
				lkPojo.setVmNUmber(lotkaVolterraPojo.getVmNUmber());
			}
		}
		totalVmPool=totalVmPool-new Double(lkPojo.getVmNUmber()).intValue();
		if(lkPojo.getVmNUmber()==null)
			Log.printLine("Cloudnot find pojo try again and change the vm and cloudlet coeff");
		return lkPojo;
		
	}
	private static List<Vm> createVM(int userId, int vms, int idShift) {
		//Creates a container to store VMs. This list is passed to the broker later
		LinkedList<Vm> list = new LinkedList<Vm>();

		//VM Parameters
		long size = 10000; //image size (MB)
		int ram = 124; //vm memory (MB)
		int mips = 100;
		long bw = 100;
		int pesNumber = 1; //number of cpus
		String vmm = "Xen"; //VMM name

		//create VMs
		Vm[] vm = new Vm[vms];

		for(int i=0;i<vms;i++){
			vm[i] = new Vm(idShift + i, userId, mips, pesNumber, ram, bw, size, vmm, new CloudletSchedulerTimeShared());
			list.add(vm[i]);
		}

		return list;
	}
}
